#!/usr/bin/ruby

# Create a firmware file suitable for upload to a DNS-323 or CH3SNAS
# device.
#
# Copyright (C) 2008 Matt Palmer <mpalmer@hezmatt.org>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
#
# Script based on information provided by Leschinsky Oleg.
#
# To construct a firmware image, you need six things: a uBoot-packaged
# kernel, a uBoot-packaged initrd, the product/custom/model IDs for the
# particular device you want to target, and the firmware signature type.
# Using the wrong values can result in the device rejecting the firmware.
#
# Known values for these the IDs and firmware signature type are:
#
#                 prod   custom   model    fwtype
# DNS-323 rev B1:    7        1       1   FrodoII
# CH3SNAS:           7        2       1   FrodoII
# DNS-343:           9        1       1   Gandolf
# DNS-321:          10        1       1   Chopper
#

require 'optparse'

def main
	opts = parse_cmdline

	validate_command_line(opts)
	
	k_size = File.stat(opts[:kernel]).size
	i_size = File.stat(opts[:initrd]).size
	d_size = opts[:defaults].nil? ? 0 : File.stat(opts[:defaults]).size
	
	ctl_header = [
		64,
		k_size,
		64 + k_size,
		i_size,
		64 + k_size + i_size,
		d_size,
		checksum(opts[:kernel]),
		checksum(opts[:initrd]),
		d_size == 0 ? 0 : checksum(opts[:defaults]),
		"\x55\xAA#{opts[:signature]}\x00\x55\xAA",
		opts[:prod_id],
		opts[:custom_id],
		opts[:model_id],
		1,
		3,
		"\x00" * 7,
		0
	].pack("V9a12c5a7V")

	File.open(opts[:output], 'w') do |fd|
		fd.write ctl_header
		fd.write File.read(opts[:kernel])
		fd.write File.read(opts[:initrd])
		fd.write File.read(opts[:defaults]) unless d_size == 0
	end
	
	puts "Firmware generation completed successfully."
end

def validate_command_line(opts)
	%w{kernel initrd defaults}.each do |k|
		next unless opts[k.to_sym]
		exit 1 unless verify_file(opts[k.to_sym], k.to_sym)
	end
	
	if opts[:signature]
		unless %w{FrodoII Chopper Gandolf}.include? opts[:signature]
			$stderr.puts "Unknown signature type #{opts[:signature]}"
			exit 1
		end
	else
		opts[:signature] = "FrodoII"
	end
end

def verify_file(file, file_type)
	if !File.exist?(file)
		puts "File #{file} does not exist!"
		return false
	end

	case file_type
	when :kernel,:initrd
		unless File.read(file, 4) == "\x27\x05\x19\x56"
			puts "WARNING: #{file} does not appear to be a u-boot image file"
			return false
		end
	when :defaults
		unless File.read(file, 2) == "\x1f\x8b"
			puts "WARNING: #{file} does not appear to be gzipped"
			return false
		end
	when :squashfs
		unless ['hsqs', 'shsq'].include?(File.read(file, 4, 0x800))
			puts "WARNING: #{file} does not appear to be a squashfs filesystem"
			return false
		end
	else
		puts "WARNING: Cannot verify #{file} (type #{file_type})"
	end
	return true
end

def checksum(file)
	sum = 0
	
	File.read(file).unpack("V*").each { |v| sum ^= v }

	sum
end

def parse_cmdline
	opts = OptionParser.new
	optargs = {}

	opts.on('-h', '--help', "Print this help") { optargs[:help] = true }
	opts.on('-k KERNEL', '--kernel KERNEL', "Specify the kernel to include in the firmware image", String) { |k| optargs[:kernel] = k }
	opts.on('-i INITRD', '--initrd INITRD', "Specify the initrd to include in the firmware image", String) { |i| optargs[:initrd] = i }
	opts.on('-d DEFAULTS', '--defaults DEFAULTS', "Specify the defaults.tar.gz to include in the firmware image (optional)", String) { |d| optargs[:defaults] = d }
	opts.on('-o OUTPUT', '--output OUTPUT', "Specify where to put the resulting firmware image", String) { |o| optargs[:output] = o }
	opts.on('-p PROD_ID', '--product-id PROD_ID', "The product ID to embed in the firmware image", Integer) { |p| optargs[:prod_id] = p }
	opts.on('-c CUSTOM_ID', '--custom-id CUSTOM_ID', "The custom ID to embed in the firmware image", Integer) { |c| optargs[:custom_id] = c }
	opts.on('-m MODEL_ID', '--model-id MODEL_ID', "The model ID to embed in the firmware image", Integer) { |m| optargs[:model_id] = m }
	opts.on('-s SIGNATURE', '--signature SIGNATURE', "The firmware signature type (either FrodoII, Chopper or Gandolf)", String) { |s| optargs[:signature] = s }

	opts.parse(ARGV)

	if optargs[:help]
		$stderr.puts opts.to_s
		exit 0
	end

	%w{kernel initrd output prod_id custom_id model_id}.each do |k|
		if optargs[k.to_sym].nil?
			$stderr.puts "Missing required argument #{k}"
			exit 1
		end
	end

	optargs
end

main
